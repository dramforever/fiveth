fn:rot [
    l, l, l,
    '1 l@ '0 l@ '2 l@
] define

fn:dip [
    l, l,
    '0 l@ run
    '1 l@
] define

fn:keep [
    l, l,
    '1 l@ '0 l@ run
    '1 l@
] define

fn:bi [
    [ keep ] dip run
] define

fn:make_entry [
    [ zs_copy ] dip
    brk_align natives sbrk
    tuck '1 natives + !
] define

brk_align '3 natives sbrk
zsw"special: over '1 natives + !
[
    drop
    lx.word '3 make_entry
    =_comp_lit over '2 natives + !
    =do_lit '1 + lx.append
    lx.append_imm
    =do_call '1 + lx.append
    [
        tuck
        '2 natives + !
        add_entry
    ] lx.append_imm
] over '2 natives + !
add_entry

[
    drop
    lx.ipos@ lx.iend@ over -
    '10 memchr
    dup [
        lx.ipos!
    ] [
        drop lx.iend@ lx.ipos!
    ] ifelse
] special:;

; Comments! They work!

[
    drop
    lx.word '4 make_entry
    =_comp_lit over '2 natives + !
    tuck '3 natives + !
    add_entry
] special:const:

fn:lx.line_end [
    lx.ipos@ lx.iend@ over - '10 memchr
    dup lx.iend@ select
] define

[
    drop
    lx.ipos@ lx.line_end over -
    '34 memchr
    dup [
        [ lx.ipos@ tuck - zs_copy ] keep
        '1 + lx.ipos!
        =do_lit '1 + lx.append
        lx.append_imm
    ] [
        nl zsw"Unmatched zs. '32 putchar zsw"quote zs.
        lx.show error
    ] ifelse
] special:zs"

fn:hello [
    ; This is the
    zs"Hello, world!" zs. ; hello world program
] define

fn:between [
    over -   [ - ] dip   <u
] define

fn:begin_case [ '0 ] define
fn:end_case [ drop ] define

fn:case [
    ; ( 0 val cond -- 0 )
    ; ( 0 val cond -- val 1 )
    ; ( 1 val cond -- 1 )
    [ over ] dip swap [
        pdrop
    ] [
        [ nip ] dip ; ( val cond )
        dip ; ( t val )
        swap [
            '1
        ] [
            drop '0
        ] ifelse
    ] ifelse
] define

'1024 sbrk const:=input_buf
'1 natives sbrk const:=iptr
=input_buf =iptr !

fn:in.insert [
    =iptr @ !
    =iptr @ '1 + =iptr !
] define

fn:cur_input [
    =input_buf
    =iptr @ =input_buf -
] define

fn:in.reset [
    =input_buf =iptr !
] define

fn:spc [
    '32 putchar
] define

fn:sh.loop
    fn:sh.line [
        getchar
        begin_case
            [
                ; Normal character
                dup putchar in.insert
                sh.line
            ] [ dup '32 '127 between ] case
            [
                ; Return key
                drop
                spc spc '59 putchar spc
                cur_input lx.input!
                lx.parse
                in.reset sh.loop
            ] [ dup '13 = ] case
            [
                ; Ctrl-D
                drop
            ] [ dup '4 = ] case
            [
                drop
                ; Backspace
                =iptr @ =input_buf = [

                ] [
                    '8 putchar '32 putchar '8 putchar
                    =iptr @ '1 - =iptr !
                ] ifelse
                sh.line
            ] [ dup '127 = ] case
            [
                ; Ctrl-C
                drop
                spc spc '59 putchar spc zsw"^C zs.
                in.reset sh.loop
            ] [ dup '3 = ] case
            [
                drop
                sh.line
            ] [ '1 ] case
        end_case
        run
    ] define
[
    nl
    lx.?top [ '62 ] [ '124 ] ifelse
    putchar
    '32 putchar
    sh.line
] define

'1 natives sbrk const:=sh.run

[
    =ds_end dsp!
    =rs_end rsp!
    lx.reset
    in.reset
    =sh.run @ '3 natives info!
    sh.loop
    zsw"(exit) zs. nl exit
] =sh.run !

fn:sh.run =sh.run @ define

fn:_words [
  dup [
    dup '1 natives + @ zs. spc
    @ _words
  ] [ drop ] ifelse
] define

fn:words [ last_word _words ] define

sh.run
