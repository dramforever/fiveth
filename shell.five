fn:rot [
    l, l, l,
    '1 l@ '0 l@ '2 l@
] define

fn:dip [
    l, l,
    '0 l@ run
    '1 l@
] define

fn:keep [
    l, l,
    '1 l@ '0 l@ run
    '1 l@
] define

fn:bi [
    [ keep ] dip tailrun
] define

fn:make_entry [
    [ zs_copy ] dip
    brk_align natives sbrk
    tuck '1 natives + !
] define

brk_align '3 natives sbrk
zsw"special: over '1 natives + !
[
    drop
    lx.word '3 make_entry
    =_comp_lit over '2 natives + !
    =do_lit '1 + lx.append
    lx.append_imm
    =do_call '1 + lx.append
    [
        tuck
        '2 natives + !
        add_entry
    ] lx.append_imm
] over '2 natives + !
add_entry

[
    drop
    lx.ipos@ lx.iend@ over -
    '10 memchr
    dup [
        lx.ipos!
    ] [
        drop lx.iend@ lx.ipos!
    ] ifelse
] special:;

; Comments! They work!

[
    drop
    lx.word '4 make_entry
    =_comp_lit over '2 natives + !
    tuck '3 natives + !
    add_entry
] special:const:

fn:hello [
    ; This is the
    zsw"Hello, zs. '32 putchar zsw"world! zs. nl ; hello world program
] define

fn:between [
    over -   [ - ] dip   <u
] define

fn:begin_case [ '0 ] define
fn:end_case [ drop ] define

fn:case [
    ; ( 0 val cond -- 0 )
    ; ( 0 val cond -- val 1 )
    ; ( 1 val cond -- 1 )
    [ over ] dip swap [
        pdrop
    ] [
        [ nip ] dip ; ( val cond )
        dip ; ( t val )
        swap [
            '1
        ] [
            drop '0
        ] ifelse
    ] ifelse
] define

'1024 sbrk const:=input_buf
'1 natives sbrk const:=iptr
=input_buf =iptr !

fn:in.insert [
    =iptr @ !
    =iptr @ '1 + =iptr !
] define

fn:cur_input [
    =input_buf
    =iptr @ =input_buf -
] define

fn:in.reset [
    =input_buf =iptr !
] define

fn:spc [
    '32 putchar
] define

fn:sh.loop
    fn:sh.line [
        getchar
        begin_case
            [
                ; Normal character
                dup putchar in.insert
                sh.line
            ] [ dup '32 '127 between ] case
            [
                ; Return key
                drop
                spc spc '59 putchar spc
                cur_input lx.input!
                lx.parse
                nl in.reset sh.loop
            ] [ dup '13 = ] case
            [
                ; Ctrl-D
                drop
            ] [ dup '4 = ] case
            [
                ; Ctrl-C
                drop
                spc spc '59 putchar spc zsw"^C zs. nl
                in.reset sh.loop
            ] [ dup '3 = ] case
            [
                drop
                sh.line
            ] [ '1 ] case
        end_case
        tailrun
    ] define
[
    lx.?top [ '62 ] [ '124 ] ifelse
    putchar
    '32 putchar
    sh.line
] define

fn:sh.run [
    =ds_end dsp!
    =rs_end rsp!
    lx.reset
    in.reset
    sh.loop
    zsw"(exit) zs. nl exit
] define

:sh.run '3 natives info!

sh.run
